#+TITLE: Yarn Vision


* Intro

** Scope

** Positionning

* Target audience

** Programmers

** Code base
Client side programs.
Legacy programs.
Scripts being run locally. Ex javascript in browsers.

* Needs

** B1. Parallelize sequential code

*** C1.1 For loop speculation

*** C1.2 Function level speculation and return value prediction

** B2. Easy to use

*** C2.1 Automatic instrumentation of for loops.
Analyzes the code for "for-loops" and adds the required library call to make it run in parallel.
Applicable to C1.1

*** C2.2 Automatic instrunentation of fonction calls.
Analyzes the code for function calls that could be executed while the current function could be executed speculatively.
To do that, the system will need to predict the return value of the called function.
The user can imbded pragma directives into the code to guide the analysis of the code.
Applicable for both C1.1 and C1.2

*** C2.3 Automatic instrumentation of dependencies.
Analyzes the code being targeted for speculative execution for dependencies that could be shared between the different epochs.
These dependencies will be instrumented so that every reads and writes are tracked and checked for violations.
Applicable for both C1.1 and C1.2

** B3. Keeps the program correct

*** C3.1 Validate accesses to epoch-shared dependencies.
Every writes to an epoch-shared dependency should be tracked and buffered.
Every reads to an epoch-shared dependency should be tracked and take into account the write buffer.
After each writes, we have to check whether a prematured read occured and rollback and violating epochs.

*** C3.2 Validate accesses to aligned words dependencies.
Modern compilers will naturally align every word so that they can be easily accessed by the processor.
These are the simplest kinds of dependency types that don't require any special support.

*** C3.3 Validate accesses to un-aligned addresses dependencies.
Un-aligned addresses occur when using variable to are smaller or bigger then the natural word size of a processor.
For example, a string can usually fit multiple caracters within a single word or a floating point value can require multiple words to store.
The aim is to provide support for these data types. 
Note that this affects the portability that is discussed in B5.

*** C3.4 Validate accesses to an address range dependencies.
Many common operations on arrays will apply a simple transformation on a large range of addresses.
For example, after allocating an array, it is customary to initialize every elements with the value 0. This can take the form of a call to the c function memset or a simple for loop.
The aim is to use more effecient data structures (a radix tree) to quickly handle these cases.

*** C3.5 Validate accesses to IO dependencies.
IO can take many shapes and can be quite difficult to support.
The aim is to provide support for common types of IO like files and network sockets.
This can be implemented by doing only a single physical read on the IO device. Every subsequent reads will be directed to a buffer instead.

*** C3.6 Error recovery.
If a error occurs during the parallel execution, the runtime component should recover by executing the original sequential code after the point of the last commit.
For example, if a for-loop is to be executed on the variable i going from 0 to 100 and that an error occurs after the value 50 was commited on i, the sequential for-loop should 
resume with i equals to 51.

** B4. Is performant

*** C4.1 The instrumented code should execute faster then the sequential code.
The runtime component will keep track of the speculative execution time and stop the speculative execution if it is taking too long.
This can be helped by the profiling information detailed in C4.2.

*** C4.2 Optimization of the instrumentation output.
The system will provide tools to help guide and profile the code instrumentation process to ensure that every instrumented sections of code don't hurt performances.
This will take the form of a special profiling mode which will aim to gather lots of runtime information. 
This information can then be used by the users to guide the instrumentation process using pragma directives.
It can also be fed back into the code instrumentation process to improve the code analysis.

** B5. Portable

*** C5.1 Number of processor cores.
The runtime component should automatically make full use of all available physical processors.
Note that hyperthreaded processors can hurt performances since they don't run in parallel. The runtime component should ignore these processors.

*** C5.2 64 bit processors.
Native implementation for the system which should not require any special consideration.

*** C5.3 32 bit processors.
Special care should be used on 32 bit processors when dealing with floating point variables that uses the IEEEXXXX standard.
These floating point values will not fit within a single word and its support will rely on caracteristic C3.3.

*** C5.4 Environment.
Should work on both Linux and Windows XP and up.


