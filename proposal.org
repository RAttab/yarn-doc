#+TITLE: LOG792 - Project Proposal

* A Speculative Multithreading System
A generic software only implementation.

** DONE Problems and Context
With the recent widespread availability of multi-core processors, there has been an increasing demand for software that can make full use of the hardware it is running on. To meet the demand, multiple tools have been created to help programmers design and implement parallel code. Unfortunately, there exists a large body of existing programs that were not designed to work in a parallel environement. These programs are generally difficult to parallelize due to their size and complexity.

This section explores the various methods used to parallelize a sequential program and the problems that the proposed tool aims to solve.

*** DONE Manual Parallelization
The first method is to do the parallezisation by hand. This involves:

1. Finding a section of code that is both a bottleneck and is inherently parallelizable.
2. Split the section of code into seperate tasks that can be executed in parallel.
3. Use the primitives provided by the current platform to run the tasks in parallel.
4. Synchronize the communications between the diferent agents running the tasks.

Each of these steps can be difficult to implement correctly. For example, a bottleneck that is inherently not parallelizable will usually contain a lot of dependency in it's computation. In order to parallelize such a piece of code and keep its computation coherent, a large amount of synchronization would need to be introduced. This would negate most if not all the benefits of the parallelization. Since it's not always obvious if a section of code is inherently parallelizable, a programmer could waste a lot of effort for very little if any benefits. The extra complexity could also introduce defects in the programs which can be difficult to detect and correct. Tools like OpenMP have been created to alleviate some of these problems but they still require a considerable amount of human intervention because they can't solve all the steps involved in parallelizing a program. 

*** DONE Automatic Parallelization
Because of all the difficulties associated with manual parallelization, another type of tools have been developped with the aim of automatically finding and parallelizing bottlenecks. These are usually part of a compiler and are implemented as optimization passes. Since the intent of the programmer is usually lost during the compilation process, this approach requires that the optimizations are conservative in nature to keep the program coherent. The information lost during the compilation process means that the process is very likely to miss some good parallelization oportunities. 

*** DONE Current SMT
To solve the problems associated with a purely compiler based parallization scheme, another type of tool has been developped. Speculative multi-threading uses a run-time component as well as a compiler based component to attempt to parallelize as much of a program as possible. Unfortunately, this approach is still an academic concept that doesn't have any robust implementation usable in the real world. Most of the research papers also concentrates on specialised hardware assisted schemes which are not widely available.


** DONE Goals for the Project
The goal of the project is to provide a robust foundation for a speculative multi-threading system which doesn't rely on any specialised hardware. This system will use both a runtime component as well as a compiler component to automatically parallelize a program with minimal user intervention.

Since it's not feasible to develop the full system during the 15 weeks allocated to this project, we will instead focus on building the key components. These key components will act both as a proof of concept and a solid foundation to construct the more advanced features. This means that the system will focus on the performances of the system by only considering a small subset of the target language.

By the end of the 15th week, the system should be capable of automatically parallelizing a simple sample program and a recomendation will be made as to whether speculative multi-threading is a viable parallelization scheme in a real world scenario.


** DONE Méthodology
This section will describe the development methodology that will be used during the course of the project.

To ensure the quality and good performance of the project, the components of the modules will be implemented in short 1 week iterations. During these iterations a small set of features will be selected to be implemented and tested with unit tests. Since performance is a key factor in the system, the system will be benchmarked starting at key milestone and then after every substantial modification of the code. Where appropriate, extra time will be scheduled for researching the workings of a specific tool or the appropriate algorithm to use for a given problem.

Since most of the implementation details has been fleshed out during the research process, the code will be implemented in parallel with the high level documentation. Our short iteration should still keep the development agile enough to quickly address any problems that might be raised during the redaction of the various high level documents. There are however a set of low level documents that depends on the results of the coding process. These will be integrated more tightly into the development process and will be part of the deliverables for the relevant iteration.


** DONE Composition de l'équipe et rôles.
N/A


** DONE Livrables et Planification

*** DONE Description des artéfacts

| Artefact       | Description                                                                                          |
|----------------+------------------------------------------------------------------------------------------------------|
| Vision         | Description of the problem and needs being filled                                                    |
|----------------+------------------------------------------------------------------------------------------------------|
| SRS            | Description of the specs of our system                                                               |
|----------------+------------------------------------------------------------------------------------------------------|
| Arch           | Description of the components and their interaction                                                  |
|----------------+------------------------------------------------------------------------------------------------------|
| Algos & Proofs | Description of the concurrent algorithms and data structures accompagnied with proof of correctness. |
|----------------+------------------------------------------------------------------------------------------------------|
| Test & perf    | Description of the testing methodology and the performance results                                   |
|----------------+------------------------------------------------------------------------------------------------------|
| Code           | Code for both the runtime kernel and the code injection modules.                                     |
|----------------+------------------------------------------------------------------------------------------------------|



*** DONE Planifications
High level desc of Annexe A.


** DONE Risques

| Risk                         | Impact | Probability | Mitigation                                                                               |
|------------------------------+--------+-------------+------------------------------------------------------------------------------------------|
| Project objectives           | Low    | Low         | Use a vision document to clearly define the objectives.                                  |
|------------------------------+--------+-------------+------------------------------------------------------------------------------------------|
| Hardware constraints         | Medium | Low         | Request specialized hardware from the school.                                            |
|------------------------------+--------+-------------+------------------------------------------------------------------------------------------|
| Reusable components          | Medium | Medium      | Research data-flow analysis algorithms in case we can't reuse the ones provided by LLVM. |
|------------------------------+--------+-------------+------------------------------------------------------------------------------------------|
| Project size                 | Medium | Medium      | Break the implementation in short 1 week chunks with plenty of testing.                  |
|------------------------------+--------+-------------+------------------------------------------------------------------------------------------|
| Requirements stability       | High   | Low         | Use a specification document to clearly define the requirements.                         |
|------------------------------+--------+-------------+------------------------------------------------------------------------------------------|
| Testability                  | High   | Medium      | Allocate extra time to isolate and test difficult and critical areas.                    |
|------------------------------+--------+-------------+------------------------------------------------------------------------------------------|
| Implementation difficulty    | Medium | High        | Fallback to simpler algorithms if necessary. Could negatively affect performances.       |
|------------------------------+--------+-------------+------------------------------------------------------------------------------------------|
| Performance factors          | High   | High        | Allocate an iteration for performance testing and optimization.                          |
|------------------------------+--------+-------------+------------------------------------------------------------------------------------------|
| External HW or SW interfaces | Low    | Medium      | Segregate/proxy any potential portability issues and test on multiple platforms.         |
|------------------------------+--------+-------------+------------------------------------------------------------------------------------------|
| Technology experience        | High   | High        | Locate and read available documentation.                                                 |
|------------------------------+--------+-------------+------------------------------------------------------------------------------------------|
| Maturity of Technology       | Medium | High        | Locate and read research papers available on the subject.                                |
|------------------------------+--------+-------------+------------------------------------------------------------------------------------------|


** DONE Techniques and Tools
This section describes the various tools that will be used to develop and manage the project.

*** DONE Project Management
For the size of this project, emacs' org-mode will be enough to manage the project. It is not necessary to use a more robust tool like Microsoft Project because all of our features have to be developped in a sequence. Org-mode's file are also much easier to manage in versionning software like git or svn.

*** DONE Document Control
Git will be used as version control for the source code and documents of our project. Since the resulting will be open sourced under the FreeBSD license, github.com will be used as a remote repository at no extra costs. The relevant repositories can be found here:

**** DONE Documents: https://github.com/RAttab/yarn-doc
**** DONE Source code: https://github.com/RAttab/yarn

*** DONE Code Development
The project will mostly use the standard linux toolchain for the development. This includes autotools, gcc, glibc, pthreads, etc. The code will also adhere to either the clean C or the C99 standard to keep it as portable as possible. The code injection part of the system wil be developped using the clang front-end for LLVM and should be conformant to the LLVM coding standards. 


** TODO Références
*** "Art of MP Prog"
*** "Dragon Book"
*** Gotta fish more research docs


** DONE Annexe

*** DONE A. Plan de travail
Note that the effort present proportions more then actual efforts. The start and end column represents the range of weeks inclusively that the task will be accomplished.

|     # | Start | End | Effort | Task/Milestone                      | Deliverables        |
|-------+-------+-----+--------+-------------------------------------+---------------------|
|     1 |     1 |   5 |     20 | Analysis                            |                     |
|   1.1 |     1 |   3 |      5 | Scoped project planification        | Project Proposal    |
|   1.2 |     3 |   5 |     15 | Full system analysis                | Vision              |
|-------+-------+-----+--------+-------------------------------------+---------------------|
|     2 |     6 |  11 |     40 | Conception                          |                     |
|   2.1 |     6 |   8 |     20 | Elicitation of system specification | SRS                 |
|   2.2 |     9 |  11 |     20 | Definition of module interaction    | Architecture        |
|-------+-------+-----+--------+-------------------------------------+---------------------|
|     3 |     1 |  14 |     70 | Development                         |                     |
|   3.1 |     1 |   7 |     35 | Runtime-kernel module               |                     |
| 3.1.1 |     1 |   1 |      5 | Conception                          | Algo desc & proofs  |
| 3.1.2 |     2 |   6 |     15 | Implementation                      | Code                |
| 3.1.3 |     3 |   7 |     15 | QA                                  | Test & perf         |
|   3.2 |     8 |  14 |     35 | Code injection module               |                     |
| 3.2.1 |     8 |  11 |     20 | Conception & Research               | Architecture        |
| 3.2.2 |     9 |  14 |     15 | Implementation                      | Code                |
|-------+-------+-----+--------+-------------------------------------+---------------------|
|     4 |    12 |  15 |     10 | Documentation                       |                     |
|   4.1 |    12 |  14 |      4 | Project presentation and demo       | Presentation slides |
|   4.2 |     7 |  15 |      6 | Project synthesis                   | Final repport       |
| 4.2.1 |    ?? |  ?? |      1 | Synthesis outline                   | Progress Repport    |
| 4.2.2 |    13 |  15 |      5 | Synthesis repport                   | Synthesis repport   |
|-------+-------+-----+--------+-------------------------------------+---------------------|
| Total |     1 |  15 |    140 |                                     |                     |
|-------+-------+-----+--------+-------------------------------------+---------------------|

